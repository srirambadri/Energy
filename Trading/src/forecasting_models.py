import pandas as pd
import numpy as np
from statsmodels.tsa.arima.model import ARIMA
from sklearn.linear_model import LinearRegression, Lasso
from sklearn.neural_network import MLPRegressor
import xgboost as xgb
import warnings

# Suppress warnings for cleaner output, as in the original notebook.
warnings.filterwarnings("ignore")

def run_forecast_model(y_train, X_train, X_test, model_name=None):

    prediction_array = None 

    if X_test is None or X_test.empty:
        print(f"Warning: X_test is empty for model '{model_name}'. Returning empty Series.")
        return pd.Series([], index=[])

    if model_name == "ARIMA":
        if X_train.empty:
            print(f"Warning: X_train is empty for ARIMA model. Returning zeros.")
            prediction_array = np.zeros(len(X_test))
        else:
            if not isinstance(y_train, pd.Series):
                y_train = pd.Series(y_train, index=X_train.index) 
            if not isinstance(X_train, pd.DataFrame):
                X_train = pd.DataFrame(X_train, index=y_train.index) 

            exog_test = X_test[X_train.columns] if not X_test.empty and not X_train.columns.empty else None

            try:
                model = ARIMA(y_train, exog=X_train, order=(1, 1, 1))
                model_fit = model.fit()
                prediction_array = model_fit.forecast(steps=len(X_test), exog=exog_test).values
            except Exception as e:
                print(f"Error training/forecasting with ARIMA: {e}")
                prediction_array = np.zeros(len(X_test))
            
    elif model_name == "XGBoost":
        model = xgb.XGBRegressor(random_state=1, n_jobs=-1)
        model.fit(X_train, y_train)
        prediction_array = model.predict(X_test)

    elif model_name == "LinearRegression":
        model = LinearRegression()        
        model.fit(X_train, y_train)
        prediction_array = model.predict(X_test)
    
    elif model_name == "Lasso":
        model = Lasso(random_state=1)
        model.fit(X_train, y_train)
        prediction_array = model.predict(X_test)
        
    elif model_name == "MLPRegressor":
        model = MLPRegressor(hidden_layer_sizes=(100,100), random_state=1, max_iter=500)
        model.fit(X_train, y_train)
        prediction_array = model.predict(X_test)

    else:
        print(f"Warning: Model '{model_name}' not recognized. Returning zeros for prediction.")
        prediction_array = np.zeros(len(X_test)) 

    if prediction_array is not None:
        prediction_series = pd.Series(prediction_array, index=X_test.index)
    else:
        prediction_series = pd.Series(np.zeros(len(X_test)), index=X_test.index)

    return prediction_series


def generate_and_average_forecasts(auction_data_train, auction_data_test,
                                   forecast_inputs_train, forecast_inputs_test):

    if auction_data_train is None or auction_data_test is None or \
       forecast_inputs_train is None or forecast_inputs_test is None:
        print("One or more input dataframes for forecasting are None. Cannot generate forecasts.")
        return None, {}

    forecast_targets = ["price_second_auction", "traded_volume_first_auction", "traded_volume_second_auction"]
    model_names = ['ARIMA', 'XGBoost', 'LinearRegression', 'Lasso', 'MLPRegressor']

    # Initialize forecast_auctions with the test data's index
    forecast_auctions = pd.DataFrame(index=auction_data_test.index)
    forecast_auctions['forecast_price_first_auction'] = auction_data_test['price_first_auction'] 

    individual_forecasts = {}

    for target_col in forecast_targets:
        print(f"Generating forecast for: {target_col}")
        
        X_train = forecast_inputs_train
        y_train = auction_data_train[target_col]
        X_test = forecast_inputs_test
        
        all_model_predictions_for_averaging = []

        for model_name in model_names: 
            prediction = run_forecast_model(y_train=y_train, X_train=X_train, X_test=X_test, model_name=model_name)
            
            # Store individual predictions
            key_name = f"{model_name}_forecast_{target_col}"
            individual_forecasts[key_name] = prediction
            
            all_model_predictions_for_averaging.append(prediction)
            
        # Compute the average of the forecasts generated by all models.
        if all_model_predictions_for_averaging:
            predictions_df = pd.concat(all_model_predictions_for_averaging, axis=1)
            averaged_predictions = predictions_df.mean(axis=1)
        else:
            averaged_predictions = pd.Series(np.zeros(len(X_test)), index=X_test.index)

        forecast_auctions[f"forecast_{target_col}"] = averaged_predictions
        
    print("All forecasts generated and averaged.")
    return forecast_auctions, individual_forecasts